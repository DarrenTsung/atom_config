var lodash_1 = require("lodash");
var enums_1 = require("../enums");
var child_process_1 = require("child_process");
var readline = require("readline");
var rx_1 = require("rx");
var path_1 = require('path');
var omnisharp_path_1 = require('../omnisharp-path');
var project_finder_1 = require("../project-finder");
var win32 = false;
if (process.platform === 'win32') {
    win32 = true;
    var env = { ATOM_SHELL_INTERNAL_RUN_AS_NODE: '1' };
}
else {
    var env = lodash_1.defaults({ ATOM_SHELL_INTERNAL_RUN_AS_NODE: '1' }, process.env);
}
var StdioDriver = (function () {
    function StdioDriver(_a) {
        var _this = this;
        var projectPath = _a.projectPath, debug = _a.debug, serverPath = _a.serverPath, findProject = _a.findProject, logger = _a.logger, timeout = _a.timeout, additionalArguments = _a.additionalArguments;
        this._outstandingRequests = new Map();
        this._currentState = enums_1.DriverState.Disconnected;
        this._disposable = new rx_1.CompositeDisposable();
        this._commandStream = new rx_1.Subject();
        this._eventStream = new rx_1.Subject();
        this._connectionStream = new rx_1.Subject();
        this._projectPath = projectPath;
        this._findProject = findProject || false;
        this._serverPath = serverPath || omnisharp_path_1.omnisharpLocation;
        this._connectionStream.subscribe(function (state) { return _this.currentState = state; });
        this._logger = logger || console;
        this._timeout = (timeout || 60) * 1000;
        this._additionalArguments = additionalArguments;
        this._disposable.add(this._commandStream);
        this._disposable.add(this._eventStream);
        this._disposable.add(this._connectionStream);
        this._disposable.add(rx_1.Disposable.create(function () {
            var iterator = _this._outstandingRequests.entries();
            var iteratee = iterator.next();
            while (!iteratee.done) {
                var _a = iteratee.value, key = _a[0], disposable = _a[1];
                _this._outstandingRequests.delete(key);
                disposable.dispose();
                iteratee = iterator.next();
            }
        }));
        this._disposable.add(rx_1.Disposable.create(function () {
            if (_this._process) {
                _this._process.removeAllListeners();
            }
        }));
    }
    Object.defineProperty(StdioDriver.prototype, "currentState", {
        get: function () { return this._currentState; },
        set: function (value) {
            if (this._currentState !== enums_1.DriverState.Error) {
                this._currentState = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    StdioDriver.prototype.dispose = function () {
        if (this._disposable.isDisposed)
            return;
        this.disconnect();
        this._disposable.dispose();
    };
    Object.defineProperty(StdioDriver.prototype, "serverPath", {
        get: function () { return this._serverPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StdioDriver.prototype, "projectPath", {
        get: function () { return this._projectPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StdioDriver.prototype, "commands", {
        get: function () { return this._commandStream; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StdioDriver.prototype, "events", {
        get: function () { return this._eventStream; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StdioDriver.prototype, "state", {
        get: function () { return this._connectionStream; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StdioDriver.prototype, "outstandingRequests", {
        get: function () { return this._outstandingRequests.size; },
        enumerable: true,
        configurable: true
    });
    StdioDriver.prototype.connect = function (_a) {
        var _this = this;
        var projectPath = _a.projectPath, findProject = _a.findProject, additionalArguments = _a.additionalArguments;
        this._seq = 1;
        this._outstandingRequests.clear();
        projectPath = projectPath || this._projectPath;
        additionalArguments = additionalArguments || this._additionalArguments;
        if (findProject || this._findProject) {
            projectPath = project_finder_1.findProject(projectPath, this._logger);
        }
        if (!projectPath) {
            var error = "Failed to determine project path for omnisharp, aborting connect()";
            this._logger.error(error);
            this.serverErr(error);
            this.disconnect();
            return;
        }
        this._connectionStream.onNext(enums_1.DriverState.Connecting);
        this._logger.log("Connecting to child @ " + process.execPath);
        this._logger.log("Path to server: " + this._serverPath);
        this._logger.log("Selected project: " + this._projectPath);
        if (win32) {
            var serverArguments = [path_1.join(__dirname, "../stdio/child.js"), "--serverPath", this._serverPath, "--projectPath", projectPath].concat(additionalArguments);
            this._logger.log("Arguments: " + serverArguments);
            this._process = child_process_1.spawn(process.execPath, serverArguments, { env: env });
        }
        else {
            var serverArguments = ["--stdio", "-s", this._projectPath, "--hostPID", process.pid].concat(additionalArguments);
            this._logger.log("Arguments: " + serverArguments);
            this._process = child_process_1.spawn(this._serverPath, serverArguments, { env: env });
        }
        if (!this._process.pid) {
            this.serverErr('failed to connect to connect to server');
            return;
        }
        this._process.stderr.on('data', function (data) { return _this._logger.error(data.toString()); });
        this._process.stderr.on('data', function (data) { return _this.serverErr(data); });
        var rl = readline.createInterface({
            input: this._process.stdout,
            output: undefined
        });
        rl.on('line', function (data) { return _this.handleData(data); });
        this.id = this._process.pid.toString();
        this._process.on('error', function (data) { return _this.serverErr(data); });
        this._process.on('close', function () { return _this.disconnect(); });
        this._process.on('exit', function () { return _this.disconnect(); });
        this._process.on('disconnect', function () { return _this.disconnect(); });
    };
    StdioDriver.prototype.serverErr = function (data) {
        var friendlyMessage = this.parseError(data);
        this._connectionStream.onNext(enums_1.DriverState.Error);
        this._process = null;
        this._eventStream.onNext({
            Type: "error",
            Event: "error",
            Seq: -1,
            Body: {
                Message: friendlyMessage
            }
        });
    };
    StdioDriver.prototype.parseError = function (data) {
        var message = data.toString();
        if (data.code === 'ENOENT' && data.path === 'mono') {
            message = 'mono could not be found, please ensure it is installed and in your path';
        }
        return message;
    };
    StdioDriver.prototype.disconnect = function () {
        if (this._process != null && this._process.pid) {
            this._process.kill("SIGTERM");
        }
        this._process = null;
        if (!this._connectionStream.isDisposed)
            this._connectionStream.onNext(enums_1.DriverState.Disconnected);
    };
    StdioDriver.prototype.request = function (command, request) {
        if (!this._process) {
            return rx_1.Observable.throw(new Error("Server is not connected, erroring out"));
        }
        var sequence = this._seq++;
        var packet = {
            Command: command,
            Seq: sequence,
            Arguments: request
        };
        var subject = new rx_1.AsyncSubject();
        this._outstandingRequests.set(sequence, subject);
        this._process.stdin.write(JSON.stringify(packet) + '\n', 'utf8');
        return subject.timeout(this._timeout, rx_1.Observable.just('Request timed out'));
    };
    StdioDriver.prototype.handleData = function (data) {
        try {
            var packet = JSON.parse(data.trim());
        }
        catch (_error) {
            this.handleNonPacket(data);
        }
        if (packet) {
            this.handlePacket(packet);
        }
    };
    StdioDriver.prototype.handlePacket = function (packet) {
        if (packet.Type === "response") {
            this.handlePacketResponse(packet);
        }
        else if (packet.Type === "event") {
            this.handlePacketEvent(packet);
        }
    };
    StdioDriver.prototype.handlePacketResponse = function (response) {
        if (this._outstandingRequests.has(response.Request_seq)) {
            var observer = this._outstandingRequests.get(response.Request_seq);
            this._outstandingRequests.delete(response.Request_seq);
            if (response.Success) {
                observer.onNext(response.Body);
            }
            else {
                observer.onError(response.Message);
            }
            observer.onCompleted();
        }
        else {
            if (response.Success) {
                this._commandStream.onNext(response);
            }
            else {
            }
        }
    };
    StdioDriver.prototype.handlePacketEvent = function (event) {
        this._eventStream.onNext(event);
        if (event.Event === "started") {
            this._connectionStream.onNext(enums_1.DriverState.Connected);
        }
    };
    StdioDriver.prototype.handleNonPacket = function (data) {
        var s = data.toString();
        this._eventStream.onNext({
            Type: "unknown",
            Event: "unknown",
            Seq: -1,
            Body: {
                Message: s
            }
        });
        var ref = s.match(/Detected an OmniSharp instance already running on port/);
        if ((ref != null ? ref.length : 0) > 0) {
            this.disconnect();
        }
    };
    return StdioDriver;
})();
module.exports = StdioDriver;
